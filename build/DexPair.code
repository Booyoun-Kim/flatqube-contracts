.macro constructor
DROP
GETGLOB 1
ISNULL
IFREF {
	CALL $c4_to_c7_with_init_storage$
}
;; constructor protection
GETGLOB 6
THROWIF 51
PUSHINT 1
SETGLOB 6
;; end constructor protection
; Decode input parameters
ENDS
; constructor DexPair
THROW 100
; end constructor DexPair
CALLREF {
	CALL $c7_to_c4$
}
TRUE
SETGLOB 7

.macro receive_macro
; function receive
THROW 100
; end function receive
IFREF {
	CALL $c7_to_c4$
}

.macro fallback_macro
; function fallback
THROW 100
; end function fallback
IFREF {
	CALL $c7_to_c4$
}

.macro resetGas
DROP
GETGLOB 1
ISNULL
IFREF {
	CALL $c4_to_c7$
}
; Decode input parameters
; Decode receiver
LDMSGADDRQ
PUSHCONT {
	;; load next cell
	LDREF
	ENDS
	CTOS
	LDMSGADDR
}
IFNOT
ENDS
;; param: receiver
; modifier onlyRoot
;; get member sender
GETGLOB 9
;; push identifier root
GETGLOB 10
SDEQ
THROWIFNOT 101
; function resetGas
PUSHINT 1000000000
PUSHINT 2
RAWRESERVE
;; transfer()
;; push identifier receiver
DUP
NEWC
STSLICECONST x62_
STSLICE
PUSHINT 109
STZEROES
STSLICECONST 0
STSLICECONST 0
ENDC
PUSHINT 128
SENDRAWMSG
; end function resetGas
; end modifier onlyRoot
DROP
IFREF {
	CALL $c7_to_c4$
}
TRUE
SETGLOB 7

.macro getRoot
DROP
GETGLOB 1
ISNULL
IFREF {
	CALL $c4_to_c7$
}
LDU 32
GETGLOB 4
ROT
SETINDEXQ 5
SETGLOB 4
; Decode input parameters
ENDS
; function getRoot
;; return
GETGLOB 4
PUSHINT 0
SETINDEXQ 2
FALSE
SETINDEXQ 1
PUSHINT 64
SETINDEXQ 4
SETGLOB 4
;; push identifier root
GETGLOB 10
; end function getRoot
;; emitting 1 value(s)
PUSH S1
EQINT -1
PUSHCONT {
	PUSH S3
	CTOS
	LDU 2
	LDMSGADDR
	DROP
	NIP
	NEWC
	STSLICECONST xc
	STSLICE
	PUSHINT 96
	STZEROES
	STSLICECONST 0
	STSLICECONST 0
	STSLICECONST xf441a21e
	PUSH S1
	STSLICER
	ENDC
	PUSHINT 0
	SENDRAWMSG
}
PUSHCONT {
	GETGLOB 4
	DUP
	INDEX 3
	PUSH S1
	INDEX 2
	GETGLOB 9
	BLKSWAP 1, 3
	INDEX 1
	NEWC
	PUSHINT 2
	STZEROES
	STI 1
	PUSHINT 3
	STZEROES
	STSLICE
	SWAP
	STGRAMS
	STDICT
	PUSHINT 104
	STZEROES
	STSLICECONST 0
	STSLICECONST 0
	GETGLOB 4
	INDEX 5
	STUR 32
	PUSH S1
	STSLICER
	ENDC
	GETGLOB 4
	INDEX 4
	SENDRAWMSG
}
IFELSE
DROP
IFREF {
	CALL $c7_to_c4$
}
TRUE
SETGLOB 7

.macro getTokenRoots
DROP
GETGLOB 1
ISNULL
IFREF {
	CALL $c4_to_c7$
}
LDU 32
GETGLOB 4
ROT
SETINDEXQ 5
SETGLOB 4
; Decode input parameters
ENDS
; function getTokenRoots
;; return
GETGLOB 4
PUSHINT 0
SETINDEXQ 2
FALSE
SETINDEXQ 1
PUSHINT 64
SETINDEXQ 4
SETGLOB 4
;; push identifier left_root
GETGLOB 14
;; push identifier right_root
GETGLOB 15
; end function getTokenRoots
;; emitting 2 value(s)
PUSH S2
EQINT -1
PUSHCONT {
	PUSH S4
	CTOS
	LDU 2
	LDMSGADDR
	DROP
	NIP
	NEWC
	STSLICECONST xc
	STSLICE
	PUSHINT 96
	STZEROES
	STSLICECONST 0
	STSLICECONST 1
	NEWC
	STSLICECONST x83cb10d1
	PUSH S3
	STSLICER
	PUSH S2
	STSLICER
	STBREFR
	ENDC
	PUSHINT 0
	SENDRAWMSG
}
PUSHCONT {
	GETGLOB 4
	DUP
	INDEX 3
	PUSH S1
	INDEX 2
	GETGLOB 9
	BLKSWAP 1, 3
	INDEX 1
	NEWC
	PUSHINT 2
	STZEROES
	STI 1
	PUSHINT 3
	STZEROES
	STSLICE
	SWAP
	STGRAMS
	STDICT
	PUSHINT 104
	STZEROES
	STSLICECONST 0
	STSLICECONST 1
	NEWC
	GETGLOB 4
	INDEX 5
	STUR 32
	PUSH S3
	STSLICER
	PUSH S2
	STSLICER
	STBREFR
	ENDC
	GETGLOB 4
	INDEX 4
	SENDRAWMSG
}
IFELSE
DROP2
IFREF {
	CALL $c7_to_c4$
}
TRUE
SETGLOB 7

.macro getVersion
DROP
GETGLOB 1
ISNULL
IFREF {
	CALL $c4_to_c7$
}
LDU 32
GETGLOB 4
ROT
SETINDEXQ 5
SETGLOB 4
; Decode input parameters
ENDS
; function getVersion
;; return
GETGLOB 4
PUSHINT 0
SETINDEXQ 2
FALSE
SETINDEXQ 1
PUSHINT 64
SETINDEXQ 4
SETGLOB 4
;; push identifier current_version
GETGLOB 12
; end function getVersion
;; emitting 1 value(s)
PUSH S1
EQINT -1
PUSHCONT {
	PUSH S3
	CTOS
	LDU 2
	LDMSGADDR
	DROP
	NIP
	NEWC
	STSLICECONST xc
	STSLICE
	PUSHINT 96
	STZEROES
	STSLICECONST 0
	STSLICECONST 0
	STSLICECONST xada94d2f
	PUSH S1
	STUR 32
	ENDC
	PUSHINT 0
	SENDRAWMSG
}
PUSHCONT {
	GETGLOB 4
	DUP
	INDEX 3
	PUSH S1
	INDEX 2
	GETGLOB 9
	BLKSWAP 1, 3
	INDEX 1
	NEWC
	PUSHINT 2
	STZEROES
	STI 1
	PUSHINT 3
	STZEROES
	STSLICE
	SWAP
	STGRAMS
	STDICT
	PUSHINT 104
	STZEROES
	STSLICECONST 0
	STSLICECONST 0
	GETGLOB 4
	INDEX 5
	STUR 32
	PUSH S1
	STUR 32
	ENDC
	GETGLOB 4
	INDEX 4
	SENDRAWMSG
}
IFELSE
DROP
IFREF {
	CALL $c7_to_c4$
}
TRUE
SETGLOB 7

.macro getVault
DROP
GETGLOB 1
ISNULL
IFREF {
	CALL $c4_to_c7$
}
LDU 32
GETGLOB 4
ROT
SETINDEXQ 5
SETGLOB 4
; Decode input parameters
ENDS
; function getVault
;; return
GETGLOB 4
PUSHINT 0
SETINDEXQ 2
FALSE
SETINDEXQ 1
PUSHINT 64
SETINDEXQ 4
SETGLOB 4
;; push identifier vault
GETGLOB 11
; end function getVault
;; emitting 1 value(s)
PUSH S1
EQINT -1
PUSHCONT {
	PUSH S3
	CTOS
	LDU 2
	LDMSGADDR
	DROP
	NIP
	NEWC
	STSLICECONST xc
	STSLICE
	PUSHINT 96
	STZEROES
	STSLICECONST 0
	STSLICECONST 0
	STSLICECONST xbd1bd325
	PUSH S1
	STSLICER
	ENDC
	PUSHINT 0
	SENDRAWMSG
}
PUSHCONT {
	GETGLOB 4
	DUP
	INDEX 3
	PUSH S1
	INDEX 2
	GETGLOB 9
	BLKSWAP 1, 3
	INDEX 1
	NEWC
	PUSHINT 2
	STZEROES
	STI 1
	PUSHINT 3
	STZEROES
	STSLICE
	SWAP
	STGRAMS
	STDICT
	PUSHINT 104
	STZEROES
	STSLICECONST 0
	STSLICECONST 0
	GETGLOB 4
	INDEX 5
	STUR 32
	PUSH S1
	STSLICER
	ENDC
	GETGLOB 4
	INDEX 4
	SENDRAWMSG
}
IFELSE
DROP
IFREF {
	CALL $c7_to_c4$
}
TRUE
SETGLOB 7

.macro getFeeParams
DROP
GETGLOB 1
ISNULL
IFREF {
	CALL $c4_to_c7$
}
LDU 32
GETGLOB 4
ROT
SETINDEXQ 5
SETGLOB 4
; Decode input parameters
ENDS
;; ret param: nominator
PUSHINT 0
;; ret param: denominator
PUSHINT 0
; function getFeeParams
;; return
GETGLOB 4
PUSHINT 0
SETINDEXQ 2
FALSE
SETINDEXQ 1
PUSHINT 64
SETINDEXQ 4
SETGLOB 4
;; push identifier fee_nominator
GETGLOB 20
;; push identifier fee_denominator
GETGLOB 21
BLKDROP2 2, 2
; end function getFeeParams
;; emitting 2 value(s)
PUSH S2
EQINT -1
PUSHCONT {
	PUSH S4
	CTOS
	LDU 2
	LDMSGADDR
	DROP
	NIP
	NEWC
	STSLICECONST xc
	STSLICE
	PUSHINT 96
	STZEROES
	STSLICECONST 0
	STSLICECONST 0
	STSLICECONST xd8d86626
	PUSH S2
	STUR 16
	PUSH S1
	STUR 16
	ENDC
	PUSHINT 0
	SENDRAWMSG
}
PUSHCONT {
	GETGLOB 4
	DUP
	INDEX 3
	PUSH S1
	INDEX 2
	GETGLOB 9
	BLKSWAP 1, 3
	INDEX 1
	NEWC
	PUSHINT 2
	STZEROES
	STI 1
	PUSHINT 3
	STZEROES
	STSLICE
	SWAP
	STGRAMS
	STDICT
	PUSHINT 104
	STZEROES
	STSLICECONST 0
	STSLICECONST 0
	GETGLOB 4
	INDEX 5
	STUR 32
	PUSH S2
	STUR 16
	PUSH S1
	STUR 16
	ENDC
	GETGLOB 4
	INDEX 4
	SENDRAWMSG
}
IFELSE
DROP2
IFREF {
	CALL $c7_to_c4$
}
TRUE
SETGLOB 7

.macro upgrade
DROP
GETGLOB 1
ISNULL
IFREF {
	CALL $c4_to_c7$
}
; Decode input parameters
; Decode code
;; decode TvmCell
LDREF
; Decode new_version
LDU 32
; Decode send_gas_to
LDMSGADDRQ
PUSHCONT {
	;; load next cell
	LDREF
	ENDS
	CTOS
	LDMSGADDR
}
IFNOT
ENDS
;; param: code
;; param: new_version
;; param: send_gas_to
; modifier onlyRoot
;; get member sender
GETGLOB 9
;; push identifier root
GETGLOB 10
SDEQ
THROWIFNOT 101
; function upgrade
;; if
;; push identifier current_version
GETGLOB 12
;; ==
;; push identifier new_version
PUSH S2
EQUAL
PUSHCONT {
	;; transfer()
	;; push identifier send_gas_to
	DUP
	NEWC
	STSLICECONST x62_
	STSLICE
	PUSHINT 109
	STZEROES
	STSLICECONST 0
	STSLICECONST 0
	ENDC
	PUSHINT 128
	SENDRAWMSG
}
PUSHCONT {
	NEWC
	;; decl: builder
	; expValue
	DUP
	; end expValue
	;; push identifier root
	GETGLOB 10
	STSLICER
	; colValue
	NIP
	; end colValue
	; expValue
	DUP
	; end expValue
	;; push identifier vault
	GETGLOB 11
	STSLICER
	; colValue
	NIP
	; end colValue
	; expValue
	DUP
	; end expValue
	;; push identifier current_version
	GETGLOB 12
	STUR 32
	; colValue
	NIP
	; end colValue
	; expValue
	DUP
	; end expValue
	;; push identifier new_version
	PUSH S3
	STUR 32
	; colValue
	NIP
	; end colValue
	; expValue
	DUP
	; end expValue
	;; push identifier send_gas_to
	PUSH S2
	STSLICER
	; colValue
	NIP
	; end colValue
	; expValue
	DUP
	; end expValue
	;; push identifier platform_code
	GETGLOB 13
	STREFR
	; colValue
	NIP
	; end colValue
	NEWC
	;; decl: dataBuilder
	; expValue
	DUP
	; end expValue
	;; push identifier left_root
	GETGLOB 14
	STSLICER
	; colValue
	NIP
	; end colValue
	; expValue
	DUP
	; end expValue
	;; push identifier right_root
	GETGLOB 15
	STSLICER
	; colValue
	NIP
	; end colValue
	; expValue
	DUP
	; end expValue
	;; push identifier lp_root
	GETGLOB 16
	STSLICER
	; colValue
	NIP
	; end colValue
	; expValue
	PUSH S1
	; end expValue
	;; push identifier dataBuilder
	PUSH S1
	STBREFR
	; colValue
	POP S2
	; end colValue
	;; push identifier code
	PUSH S4
	SETCODE
	;; push identifier code
	PUSH S4
	CTOS
	BLESS
	POP c3
	;; push identifier builder
	PUSH S1
	ENDC
	CALLREF {
		CALL $:onCodeUpgrade$
	}
	DROP2
}
IFELSE
;; end if
; end function upgrade
; end modifier onlyRoot
BLKDROP 3
CALLREF {
	CALL $c7_to_c4$
}
TRUE
SETGLOB 7

.internal-alias :onCodeUpgrade, 2
.internal :onCodeUpgrade
PUSHINT 1
CALL 1
;; param: upgrade_data
; function onCodeUpgrade
;; push identifier upgrade_data
DUP
CTOS
;; decl: s
; expValue
DUP
; end expValue
;; decode address
LDMSGADDR
;; decode address
LDMSGADDR
LDU 32
LDU 32
;; decode address
LDMSGADDR
; colValue
POP S6
; end colValue
BLKSWAP 4, 1
BLKSWAP 4, 1
BLKSWAP 4, 1
BLKSWAP 4, 1
BLKSWAP 4, 1
;; decl: root_
;; decl: vault_
;; decl: old_version
;; decl: new_version
;; decl: send_gas_to
;; if
;; push identifier old_version
PUSH S2
PUSHCONT {
	;; set default state vars
	PUSHSLICE x8000000000000000000000000000000000000000000000000000000000000000001_
	SETGLOB 10
	PUSHSLICE x8000000000000000000000000000000000000000000000000000000000000000001_
	SETGLOB 11
	PUSHINT 0
	SETGLOB 12
	NEWC
	ENDC
	SETGLOB 13
	PUSHSLICE x8000000000000000000000000000000000000000000000000000000000000000001_
	SETGLOB 14
	PUSHSLICE x8000000000000000000000000000000000000000000000000000000000000000001_
	SETGLOB 15
	PUSHSLICE x8000000000000000000000000000000000000000000000000000000000000000001_
	SETGLOB 16
	PUSHINT 0
	SETGLOB 17
	PUSHINT 0
	SETGLOB 18
	PUSHINT 0
	SETGLOB 19
	PUSHINT 0
	SETGLOB 20
	PUSHINT 0
	SETGLOB 21
	;; end set default state vars
}
IFNOT
;; end if
; expValue
; end expValue
;; push identifier root_
PUSH S4
; colValue
SETGLOB 10
; end colValue
; expValue
; end expValue
;; push identifier vault_
PUSH S3
; colValue
SETGLOB 11
; end colValue
; expValue
; end expValue
;; push identifier new_version
PUSH S1
; colValue
SETGLOB 12
; end colValue
; expValue
PUSH S5
; end expValue
LDREF
; colValue
POP S7
; end colValue
; expValue
; end expValue
; colValue
SETGLOB 13
; end colValue
; expValue
PUSH S5
; end expValue
LDREFRTOS
SWAP
; colValue
POP S7
; end colValue
;; decl: data
; expValue
DUP
; end expValue
;; decode address
LDMSGADDR
; colValue
POP S2
; end colValue
; expValue
; end expValue
; colValue
SETGLOB 14
; end colValue
; expValue
DUP
; end expValue
;; decode address
LDMSGADDR
; colValue
POP S2
; end colValue
; expValue
; end expValue
; colValue
SETGLOB 15
; end colValue
PUSHINT 1000000000
PUSHINT 2
RAWRESERVE
;; transfer()
;; push identifier send_gas_to
PUSH S1
NEWC
STSLICECONST x62_
STSLICE
PUSHINT 109
STZEROES
STSLICECONST 0
STSLICECONST 0
ENDC
PUSHINT 128
SENDRAWMSG
BLKDROP 7
; end function onCodeUpgrade
DROP
CALLREF {
	CALL $c7_to_c4$
}
COMMIT
THROW 0

.macro afterInitialize
DROP
GETGLOB 1
ISNULL
IFREF {
	CALL $c4_to_c7$
}
; Decode input parameters
; Decode send_gas_to
LDMSGADDRQ
PUSHCONT {
	;; load next cell
	LDREF
	ENDS
	CTOS
	LDMSGADDR
}
IFNOT
ENDS
;; param: send_gas_to
; modifier onlyRoot
;; get member sender
GETGLOB 9
;; push identifier root
GETGLOB 10
SDEQ
THROWIFNOT 101
; function afterInitialize
PUSHINT 1000000000
PUSHINT 2
RAWRESERVE
;; if
;; get member value
;; push identifier lp_root
GETGLOB 16
PARSEMSGADDR
INDEX 3
PLDU 256
EQINT 0
PUSHCONT {
	;; Remote call IDexVault.addLiquidityToken
	;; push identifier vault
	GETGLOB 11
	NEWC
	STSLICECONST x62_
	STSLICE
	PUSHINT 109
	STZEROES
	STSLICECONST 0
	STSLICECONST 1
	NEWC
	STSLICECONST x47aa4332
	;; pair
	MYADDR
	STSLICER
	;; left_root
	;; push identifier left_root
	GETGLOB 14
	STSLICER
	;; right_root
	;; push identifier right_root
	GETGLOB 15
	STSLICER
	NEWC
	;; send_gas_to
	;; push identifier send_gas_to
	PUSH S3
	STSLICER
	STBREFR
	STBREFR
	ENDC
	PUSHINT 128
	SENDRAWMSG
}
PUSHCONT {
	;; transfer()
	;; push identifier send_gas_to
	DUP
	NEWC
	STSLICECONST x62_
	STSLICE
	PUSHINT 109
	STZEROES
	STSLICECONST 0
	STSLICECONST 0
	ENDC
	PUSHINT 128
	SENDRAWMSG
}
IFELSE
;; end if
; end function afterInitialize
; end modifier onlyRoot
DROP
CALLREF {
	CALL $c7_to_c4$
}
TRUE
SETGLOB 7

.macro liquidityTokenRootDeployed
DROP
GETGLOB 1
ISNULL
IFREF {
	CALL $c4_to_c7$
}
; Decode input parameters
; Decode lp_root_
LDMSGADDRQ
PUSHCONT {
	;; load next cell
	LDREF
	ENDS
	CTOS
	LDMSGADDR
}
IFNOT
; Decode send_gas_to
LDMSGADDRQ
PUSHCONT {
	;; load next cell
	LDREF
	ENDS
	CTOS
	LDMSGADDR
}
IFNOT
ENDS
;; param: lp_root_
;; param: send_gas_to
; modifier onlyVault
;; get member sender
GETGLOB 9
;; push identifier vault
GETGLOB 11
SDEQ
THROWIFNOT 115
; function liquidityTokenRootDeployed
PUSHINT 1000000000
PUSHINT 2
RAWRESERVE
; expValue
; end expValue
;; push identifier lp_root_
PUSH S1
; colValue
SETGLOB 16
; end colValue
;; transfer()
;; push identifier send_gas_to
DUP
NEWC
STSLICECONST x62_
STSLICE
PUSHINT 109
STZEROES
STSLICECONST 0
STSLICECONST 0
ENDC
PUSHINT 128
SENDRAWMSG
; end function liquidityTokenRootDeployed
; end modifier onlyVault
DROP2
CALLREF {
	CALL $c7_to_c4$
}
TRUE
SETGLOB 7

.macro c7_to_c4
GETGLOB 2
NEWC
STU 256
GETGLOB 3
STUR 64
GETGLOB 6
STUR 1
NEWC
GETGLOB 14
GETGLOB 15
GETGLOB 16
REVERSE 4, 0
STSLICE
STSLICE
STSLICE
NEWC
GETGLOB 17
GETGLOB 18
GETGLOB 19
REVERSE 4, 0
STU 128
STU 128
STU 128
GETGLOB 10
GETGLOB 11
GETGLOB 12
GETGLOB 13
GETGLOB 20
GETGLOB 21
REVERSE 9, 0
STBREF
STBREF
STSLICE
STSLICE
STU 32
STREF
STU 16
STU 16
ENDC
POP C4

.macro c4_to_c7
PUSHROOT
CTOS        ; c4
LDU 256      ; pubkey c4
LDU 64      ; pubkey timestamp c4
LDU 1       ; pubkey [timestamp] constructor_flag memory
LDREFRTOS
LDMSGADDR
LDMSGADDR
SETGLOB 16
SETGLOB 15
SETGLOB 14
LDREFRTOS
LDU 128
LDU 128
PLDU 128
SETGLOB 19
SETGLOB 18
SETGLOB 17
LDMSGADDR
LDMSGADDR
LDU 32
LDREF
LDU 16
PLDU 16
SETGLOB 21
SETGLOB 20
SETGLOB 13
SETGLOB 12
SETGLOB 11
SETGLOB 10
TRUE
SETGLOB 1   ; pubkey [timestamp] constructor_flag
SETGLOB 6   ; pubkey [timestamp]
SETGLOB 3   ; D
SETGLOB 2

.macro c4_to_c7_with_init_storage
PUSHROOT
CTOS        ; c4
DUP        ; c4 c4
SBITS      ; c4 bits
GTINT 1    ; c4 bits>1
PUSHCONT {
	LDU 256      ; pubkey c4
	LDU 64      ; pubkey timestamp c4
	LDU 1       ; pubkey [timestamp] constructor_flag memory
	LDREFRTOS
	LDMSGADDR
	LDMSGADDR
	SETGLOB 16
	SETGLOB 15
	SETGLOB 14
	LDREFRTOS
	LDU 128
	LDU 128
	PLDU 128
	SETGLOB 19
	SETGLOB 18
	SETGLOB 17
	LDMSGADDR
	LDMSGADDR
	LDU 32
	LDREF
	LDU 16
	PLDU 16
	SETGLOB 21
	SETGLOB 20
	SETGLOB 13
	SETGLOB 12
	SETGLOB 11
	SETGLOB 10
	TRUE
	SETGLOB 1   ; pubkey [timestamp] constructor_flag
	SETGLOB 6   ; pubkey [timestamp]
	SETGLOB 3   ; D
	SETGLOB 2
}
PUSHCONT {
	PLDDICT   ; D
	; init root
	PUSHSLICE x8000000000000000000000000000000000000000000000000000000000000000001_
	SETGLOB 10
	; init vault
	PUSHSLICE x8000000000000000000000000000000000000000000000000000000000000000001_
	SETGLOB 11
	; init current_version
	PUSHINT 0
	SETGLOB 12
	; init platform_code
	NEWC
	ENDC
	SETGLOB 13
	; init left_root
	PUSHSLICE x8000000000000000000000000000000000000000000000000000000000000000001_
	SETGLOB 14
	; init right_root
	PUSHSLICE x8000000000000000000000000000000000000000000000000000000000000000001_
	SETGLOB 15
	; init lp_root
	PUSHSLICE x8000000000000000000000000000000000000000000000000000000000000000001_
	SETGLOB 16
	; init lp_supply
	PUSHINT 0
	SETGLOB 17
	; init left_balance
	PUSHINT 0
	SETGLOB 18
	; init right_balance
	PUSHINT 0
	SETGLOB 19
	; init fee_nominator
	PUSHINT 0
	SETGLOB 20
	; init fee_denominator
	PUSHINT 0
	SETGLOB 21
	; set contract pubkey
	PUSHINT 0
	SWAP
	PUSHINT 64
	DICTUGET
	THROWIFNOT 61
	PLDU 256
	SETGLOB 2
	PUSHINT 0 ; timestamp
	SETGLOB 3
	PUSHINT 0 ; constructor_flag
	SETGLOB 6
	TRUE
	SETGLOB 1
	;; init state var: lp_supply
	PUSHINT 0
	SETGLOB 17
	;; init state var: left_balance
	PUSHINT 0
	SETGLOB 18
	;; init state var: right_balance
	PUSHINT 0
	SETGLOB 19
	;; init state var: fee_nominator
	PUSHINT 3
	SETGLOB 20
	;; init state var: fee_denominator
	PUSHINT 1000
	SETGLOB 21
}
IFELSE

.internal-alias :main_internal, 0
.internal :main_internal
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Function: main_internal
;; param: contract_balance
;; param: msg_balance
;; param: int_msg_info
;; param: msg_body_slice
PUSHINT 0  ; main_external trans id
PUSH S2
CTOS
LDU 4       ; bounced tail
LDMSGADDR   ; bounced src tail
DROP
SETGLOB 9
MODPOW2 1
; beg set default params for responsible func
GETGLOB 4
; bounce
TRUE
SETINDEXQ 1
; tons
PUSHINT 10000000
SETINDEXQ 2
; currency
NULL
SETINDEXQ 3
; flag
PUSHINT 0
SETINDEXQ 4
SETGLOB 4
; end set default params for responsible func
IFRET
PUSH S1    ; body
SEMPTY     ; isEmpty
DUP        ; isEmpty isEmpty
PUSHCONT {
	DROP    ;
	PUSH S1 ; body
	LDU 32  ; funcId body'
	PUSH S1 ; funcId body' funcId
	EQINT 0 ; funcId body' isZero
	DUP     ; funcId body' isZero isZero
	PUSHCONT {
 		; funcId body' isZero
		BLKDROP2 2, 1; isZero
	}
	IF
}
IFNOT
; [funcId body'] doReceive
PUSHCONT {
	CALL $receive_macro$
}
IFJMP
SWAP
CALLREF {
	CALL $public_function_selector$
}
GETGLOB 7
ISNULL
PUSHCONT {
	DROP2 ; funcId and restSlice
	CALLREF {
		CALL $fallback_macro$
	}
}
IF

.internal-alias :main_external, -1
.internal :main_external
PUSHINT -1 ; main_external trans id
PUSHSLICE x8000000000000000000000000000000000000000000000000000000000000000001_
SETGLOB 9
PUSH S1
CALLREF {
	CALL $c4_to_c7_with_init_storage$
}
LDU 1 ; haveSign msgSlice
SWAP
PUSHCONT {
	PUSHINT 512
	LDSLICEX ; signatureSlice msgSlice
	DUP      ; signatureSlice msgSlice msgSlice
	HASHSU   ; signatureSlice msgSlice hashMsgSlice
	SWAP  ; signatureSlice hashMsgSlice msgSlice
	LDU 1 ; signatureSlice hashMsgSlice havePubkey msgSlice
	SWAP  ; signatureSlice hashMsgSlice msgSlice havePubkey
	PUSHCONT {
		LDU 256       ; signatureSlice hashMsgSlice pubkey msgSlice
		XCHG s3
		SWAP
	}
	PUSHCONT {
		XCHG s2
		GETGLOB 2
	}
	IFELSE
	CHKSIGNU      ; msgSlice isSigned
	THROWIFNOT 40 ; msgSlice
}
PUSHCONT {
	LDU 1      ; havePubkey msgSlice
	SWAP       ; msgSlice havePubkey
	THROWIF 58 ; msgSlice
}
IFELSE
LDU 64                         ; timestamp msgSlice
SWAP                           ; msgSlice timestamp
CALL $replay_protection_macro$ ; msgSlice
LDU 32  ; expireAt msgSlice
SWAP    ; msgSlice expireAt
NOW     ; msgSlice expireAt now
GREATER ; msgSlice expireAt>now
THROWIFNOT 57
LDU  32 ; funcId body
SWAP    ; body funcId
CALLREF {
	CALL $public_function_selector$
}
GETGLOB 7
ISNULL
PUSHCONT {
	DROP2 ; funcId and restSlice
	CALLREF {
		CALL $fallback_macro$
	}
}
IF

.macro public_function_selector
DUP
PUSHINT 721356139
LEQ
PUSHCONT {
	DUP
	PUSHINT 63639761
	EQUAL
	IFJMPREF {
		CALL $getTokenRoots$
	}
	DUP
	PUSHINT 115515182
	EQUAL
	IFJMPREF {
		CALL $resetGas$
	}
	DUP
	PUSHINT 721356139
	EQUAL
	IFJMPREF {
		CALL $afterInitialize$
	}
}
IFJMP
DUP
PUSHINT 1125423194
LEQ
PUSHCONT {
	DUP
	PUSHINT 766070063
	EQUAL
	IFJMPREF {
		CALL $getVersion$
	}
	DUP
	PUSHINT 1025233701
	EQUAL
	IFJMPREF {
		CALL $getVault$
	}
	DUP
	PUSHINT 1125423194
	EQUAL
	IFJMPREF {
		CALL $liquidityTokenRootDeployed$
	}
}
IFJMP
DUP
PUSHINT 1756716863
LEQ
PUSHCONT {
	DUP
	PUSHINT 1490576934
	EQUAL
	IFJMPREF {
		CALL $getFeeParams$
	}
	DUP
	PUSHINT 1688565960
	EQUAL
	IFJMPREF {
		CALL $upgrade$
	}
	DUP
	PUSHINT 1756716863
	EQUAL
	IFJMPREF {
		CALL $constructor$
	}
}
IFJMP
DUP
PUSHINT 1950458398
EQUAL
IFJMPREF {
	CALL $getRoot$
}
