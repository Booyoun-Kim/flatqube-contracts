pragma ever-solidity >= 0.62.0;

pragma AbiHeader time;
pragma AbiHeader expire;
pragma AbiHeader pubkey;

import "./libraries/OrderGas.tsol";
import "./libraries/OrderErrors.tsol";
import "./libraries/OrderPayloads.tsol";
import "./libraries/OrderRootOperationErrors.tsol";

import "./structures/IOrderRootCreateResult.tsol";

import "./interfaces/IOrderRoot.tsol";
import "./interfaces/IOrderFactory.tsol";
import "./interfaces/IOrderRootCallbacks.tsol";
import "./interfaces/IOrderRootEvents.tsol";

import "./Order.tsol";

import "@broxus/contracts/contracts/libraries/MsgFlag.tsol";
import "tip3/contracts/interfaces/ITokenRoot.tsol";
import "tip3/contracts/interfaces/ITokenWallet.tsol";
import "tip3/contracts/interfaces/IAcceptTokensTransferCallback.tsol";

contract OrderRoot is IOrderRoot, IOrderRootEvents, IAcceptTokensTransferCallback {
    address factory;
    address spentToken;
    
    uint32 version;
    uint32 versionOrder;

    TvmCell orderCode;
    TvmCell orderPlatformCode;

    address spentTokenWallet;
    address deployer;
    address dexRoot;

    OrderFeeParams fee;

    constructor() public { revert(); }

    modifier onlyFactory() {
        require(
            msg.sender.value != 0 && msg.sender == factory,
            OrderErrors.NOT_FACTORY_LIMIT_ORDER_ROOT
        );
        _;
    }

    function onTokenWallet(address _wallet) external {
        require(
            msg.sender.value != 0 && msg.sender == spentToken,
            OrderErrors.NOT_TOKEN1_ROOT
        );
        tvm.rawReserve(address(this).balance - msg.value, 0);
        spentTokenWallet = _wallet;

        IOrderFactory(factory).onOrderRootDeployedCallback{
            value: 0,
            flag: MsgFlag.ALL_NOT_RESERVED
        }(address(this), spentToken, deployer);
    }

    function onTokenWalletReceive(address _wallet) external pure {
        require(msg.sender.value != 0, OrderErrors.NOT_EMPTY_MSG_SENDER);
        _wallet.transfer(0, false, MsgFlag.REMAINING_GAS + MsgFlag.IGNORE_ERRORS);
    }

    function onTokenWalletBeneficiary(address _wallet) external pure {
        require(msg.sender.value != 0, OrderErrors.NOT_EMPTY_MSG_SENDER);
        _wallet.transfer(0, false, MsgFlag.REMAINING_GAS + MsgFlag.IGNORE_ERRORS);
    }

    onBounce(TvmSlice body) external view {
        tvm.rawReserve(OrderGas.TARGET_BALANCE_ROOT, 0);
        uint32 functionId = body.decode(uint32);

        if (
            functionId == tvm.functionId(ITokenRoot.deployWallet) &&
            msg.sender == spentToken
        ){
            deployer.transfer(
                0,
                false,
                MsgFlag.ALL_NOT_RESERVED + MsgFlag.DESTROY_IF_ZERO
            );
        }
    }

    function getFeeParams() override external view responsible returns (OrderFeeParams params) {
		return { value: 0, bounce: false, flag: MsgFlag.REMAINING_GAS } (fee);
	}

    function getVersion() override external view responsible returns (uint32) {
        return { value: 0, bounce: false, flag: MsgFlag.REMAINING_GAS } (version);
    }

    function getSpentToken() override external view responsible returns(address) {
        return { value: 0, bounce: false, flag: MsgFlag.REMAINING_GAS } (spentToken);
    }

    function getSpentWallet() override external view responsible returns (address) {
        return { value: 0, bounce: false, flag: MsgFlag.REMAINING_GAS } (spentTokenWallet);
    }

    function getFactory() override external view responsible returns(address) {
        return { value: 0, bounce: false, flag: MsgFlag.REMAINING_GAS } (factory);
    }

    function getDeployer() override external view responsible returns(address) {
        return { value: 0, bounce: false, flag: MsgFlag.REMAINING_GAS } (deployer);
    }

    function getDex() override external view responsible returns(address) {
        return { value: 0, bounce: false, flag: MsgFlag.REMAINING_GAS } (dexRoot);
    }

    function expectedAddressOrder(
        address _factory,
        address _root,
        address _owner,
        address _spentToken,
        address _receiveToken,
        uint64 timeTx,
        uint64 nowTx
    ) override external view responsible returns (address)
    {
        return {
            value: 0,
            bounce: false,
            flag: MsgFlag.REMAINING_GAS
        } address(tvm.hash(tvm.buildStateInit({
            contr: Order,
            varInit: {
                factory: _factory,
                root: _root,
                owner: _owner,
                spentToken: _spentToken,
                receiveToken: _receiveToken,
                timeTx: timeTx,
                nowTx: nowTx
            },
            code: orderCode
            })
        ));
    }

    function setFeeParams(OrderFeeParams params) override external onlyFactory() {
        tvm.rawReserve(OrderGas.TARGET_BALANCE_ROOT, 0);
        fee = params;
        factory.transfer(
            0,
            false,
            MsgFlag.ALL_NOT_RESERVED + MsgFlag.IGNORE_ERRORS
        );
    }

    function buildPayload(
        uint64 callbackId,
        address user,
        address tokenReceive,
        uint128 expectedTokenAmount,
        uint128 deployWalletValue,
        uint256 backPK,
        uint256 backMatchingPK
    ) external pure returns (TvmCell) {
        TvmBuilder builderBackendPK;
        builderBackendPK.store(backPK);
        builderBackendPK.store(backMatchingPK);

        TvmBuilder builder;
        builder.store(callbackId);
        builder.store(user);
        builder.store(tokenReceive);
        builder.store(expectedTokenAmount);
        builder.store(deployWalletValue);
        builder.storeRef(builderBackendPK);

        return builder.toCell();
    }

    function onAcceptTokensTransfer(
        address tokenRoot,
        uint128 amount,
        address sender,
        address, /*senderWallet*/
        address originalGasTo,
        TvmCell payload
    ) external override {
        require(msg.sender.value != 0);
        tvm.rawReserve(address(this).balance - msg.value, 0);

        TvmSlice payloadSlice = payload.toSlice();
        uint64 callbackId;
        if (payloadSlice.bits() >= 64) {
            callbackId = payloadSlice.decode(uint64);
        }

        TvmSlice dataPK = payloadSlice.loadRefAsSlice();

        uint16 errorCode = _checkOperationData(
            msg.sender,
            msg.sender.value,
            payloadSlice,
            dataPK
        );

        if (errorCode == 0) {
            (
                address user,
                address receiveToken,
                uint128 expectedAmount,
                uint128 deployWalletValue
            ) = payloadSlice.decode(address, address, uint128, uint128);

            if (user.value == 0) {
                user = sender;
            }

            address orderAddress = _createOrder(
                expectedAmount,
                amount,
                user,
                receiveToken,
                dataPK
            );

            emit CreateOrder(orderAddress, user, tokenRoot, amount, receiveToken, expectedAmount);

            if (callbackId > 0) {
                IOrderRootCallbacks(user).onOrderCreateOrderSuccess {
                    value: OrderGas.OPERATION_CALLBACK_BASE,
                    flag: MsgFlag.SENDER_PAYS_FEES + MsgFlag.IGNORE_ERRORS,
                    bounce: false
                }(callbackId, orderAddress);

                if (user != sender) {
                    IOrderRootCallbacks(sender).onOrderCreateOrderSuccess {
                        value: OrderGas.OPERATION_CALLBACK_BASE,
                        flag: MsgFlag.SENDER_PAYS_FEES + MsgFlag.IGNORE_ERRORS,
                        bounce: false
                    }(callbackId, orderAddress);
                }
            }

            ITokenRoot(receiveToken).deployWallet {
                value: OrderGas.DEPLOY_EMPTY_WALLET_VALUE,
                flag: MsgFlag.SENDER_PAYS_FEES,
                callback: OrderRoot.onTokenWalletReceive
            }(user, OrderGas.DEPLOY_EMPTY_WALLET_GRAMS);

            ITokenRoot(receiveToken).deployWallet {
                value: OrderGas.DEPLOY_EMPTY_WALLET_VALUE,
                flag: MsgFlag.SENDER_PAYS_FEES,
                callback: OrderRoot.onTokenWalletBeneficiary
            }(fee.beneficiary, OrderGas.DEPLOY_EMPTY_WALLET_GRAMS);

            ITokenWallet(spentTokenWallet).transfer{
                value: 0, flag: MsgFlag.ALL_NOT_RESERVED,
                bounce: false
            }(
                amount,
                orderAddress,
                (deployWalletValue <= OrderGas.DEPLOY_EMPTY_WALLET_GRAMS? deployWalletValue : OrderGas.DEPLOY_EMPTY_WALLET_GRAMS),
                orderAddress,
                true,
                payload
            );
        }

        if (errorCode != 0) {
            emit CreateOrderReject();
            if (callbackId > 0){
                IOrderRootCallbacks(sender).onOrderCreateOrderReject{
                    value: OrderGas.OPERATION_CALLBACK_BASE,
                    flag: MsgFlag.SENDER_PAYS_FEES + MsgFlag.IGNORE_ERRORS,
                    bounce: false
                }(callbackId);
            }

            ITokenWallet(msg.sender).transfer{
                value: 0,
                flag: MsgFlag.ALL_NOT_RESERVED + MsgFlag.IGNORE_ERRORS,
                bounce: false
            }(
                amount,
                sender,
                uint128(0),
                originalGasTo,
                true,
                OrderPayloads.buildCancelPayloadOrderRoot(payload)
            );
        }
    }

    function _checkOperationData(
        address msgSender,
        uint256 msgValue,
        TvmSlice payloadSlice,
        TvmSlice dataPkSlice
    ) private view returns(uint16){
        if (msgValue < OrderGas.DEPLOY_ORDER_MIN_VALUE) return OrderRootOperationErrors.VALUE_TOO_LOW;
        if (msgSender != spentTokenWallet) return OrderRootOperationErrors.NOT_SPENT_TOKEN_ROOT;
        if (payloadSlice.bits() != 790 || dataPkSlice.bits() != 512) return OrderRootOperationErrors.INVALID_PAYLOAD;

        return 0;
    }

    function _createOrder(
        uint128 _expectedAmount,
        uint128 _amount,
        address _sender,
        address _receiveToken,
        TvmSlice _dataPK
    ) private view returns(address){
        (
            uint256 backPubKey,
            uint256 backMatchingPK
        ) = _dataPK.decode(uint256, uint256);

        return (new Order {
            stateInit: buildState(_sender, orderCode, _receiveToken),
            value: OrderGas.DEPLOY_ORDER
        }(
            _expectedAmount,
            _amount,
            backPubKey,
            backMatchingPK,
            dexRoot,
            fee,
            orderPlatformCode,
            version
        ));
    }

    function buildState(
        address sender,
        TvmCell _code,
        address _receiveToken
    ) internal view returns (TvmCell){
        return tvm.buildStateInit({
            contr: Order,
            varInit: {
                factory: factory,
                root: address(this),
                owner: sender,
                spentToken: spentToken,
                receiveToken: _receiveToken,
                timeTx: tx.timestamp,
                nowTx: uint64(now)
                },
            code: _code
        });
    }

    function setOrderCode(TvmCell _code) override external onlyFactory() {
        tvm.rawReserve(address(this).balance - msg.value, 0);

        uint32 prevVersion = versionOrder;
        versionOrder++;
        orderCode = _code;

        emit OrderCodeUpgraded(prevVersion, versionOrder);
        factory.transfer(0, false, MsgFlag.ALL_NOT_RESERVED + MsgFlag.IGNORE_ERRORS);
    }

    function upgrade(
        TvmCell _code, 
        uint32 _newVersion, 
        address _sendGasTo
    ) override external onlyFactory() {
        if (version == _newVersion) {
            tvm.rawReserve(address(this).balance - msg.value, 0);
            _sendGasTo.transfer({ value: 0, flag: MsgFlag.ALL_NOT_RESERVED + MsgFlag.IGNORE_ERRORS });
        } else {
            emit OrderRootCodeUpgraded(_newVersion);

            TvmCell data = abi.encode(
                factory, spentToken, spentTokenWallet, version, _newVersion, versionOrder,
                deployer, fee, orderCode, abi.encode(dexRoot, orderPlatformCode)
            );

            tvm.setcode(_code);
            tvm.setCurrentCode(_code);

            onCodeUpgrade(data);
        }
    }

    function onCodeUpgrade(TvmCell _data) private {
        tvm.rawReserve(OrderGas.TARGET_BALANCE_ROOT, 0);

        uint32 _oldVersion;
        TvmCell data;
        (
            factory,
            spentToken,
            spentTokenWallet,
            _oldVersion,
            version,
            versionOrder,
            deployer,
            fee,
            orderCode,
            data
        ) = abi.decode(_data, (
            address, address, address, uint32, uint32,
            uint32, address, OrderFeeParams, TvmCell, TvmCell
        ));

        (dexRoot, orderPlatformCode) = abi.decode(data, (address, TvmCell));

        if (_oldVersion == 0){
            ITokenRoot(spentToken).deployWallet{
                value: OrderGas.DEPLOY_EMPTY_WALLET_VALUE,
                flag: MsgFlag.SENDER_PAYS_FEES,
                callback: OrderRoot.onTokenWallet
            }(
                address(this),
                OrderGas.DEPLOY_EMPTY_WALLET_GRAMS
            );

            if (fee.beneficiary.value == 0) {
                fee.beneficiary = factory;
            }

            deployer.transfer({
                value: 0,
                flag: MsgFlag.ALL_NOT_RESERVED + MsgFlag.IGNORE_ERRORS,
                bounce: false
            });
        } else {

            factory.transfer({
                value: 0,
                flag: MsgFlag.ALL_NOT_RESERVED + MsgFlag.IGNORE_ERRORS,
                bounce: false
            });
        }
    }
}
